<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Visualización de la Red SDN</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <style>
    body { font-family: Arial, sans-serif; }
    svg {
    border: 1px solid black;
    }
    .link { stroke: #999; stroke-width: 2px; }
    .node { fill: steelblue; stroke: white; stroke-width: 2px; cursor: pointer; }
    .highlight { stroke: red; stroke-width: 4px; }
  </style>
</head>
<body>
  <h2>Visualización de la Red SDN</h2>

  <div id="snapshot-info" style="font-size: 1.1em; margin-bottom: 10px;">
    Instantánea: <span id="snapshot-counter">—</span>
  </div>


  <div id="best-path-display" style="font-size: 1.1em; margin-bottom: 10px;">
    Ruta óptima: —
  </div>

  <div id="best-cost">
    Coste: <span id="path-cost">—</span>
  </div>
  
  
  <svg width="800" height="1000"></svg>

  <script>
    const socket = io.connect('http://127.0.0.1:5000');
    const svg = d3.select("svg");
    let nodes = [];
    let links = [];
    let linkElements, nodeElements, labelElements;
    let simulation;

    function initializeNetwork(data) {
      nodes = data.switches.map(d => ({ id: d }));
      let nodeMap = new Map(nodes.map(n => [n.id, n]));

      links = data.links.map(l => ({
        source: nodeMap.get(l.src),
        target: nodeMap.get(l.dst),
        load: l.load,
        delay: l.delay,
        packet_loss: l.packet_loss
      }));

      simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(100))
        .force("charge", d3.forceManyBody().strength(-400))
        .force("center", d3.forceCenter(300, 200));

      linkElements = svg.selectAll(".link")
        .data(links)
        .enter().append("line")
        .attr("class", "link")
        .attr("stroke-width", d => d.load * 10)

      linkElements.append("title")
        .text(d =>
          `Enlace ${d.source.id}→${d.target.id}\n` +
          `Carga: ${(d.load*100).toFixed(1)}%\n` +
          `Delay: ${(d.delay*1000).toFixed(1)}ms\n` +
          `Pérdida: ${(d.packet_loss*100).toFixed(1)}%`
        );
        
        nodeElements = svg.selectAll(".node")
        .data(nodes)
        .enter().append("image")
          .attr("class", "node")
          .attr("xlink:href", "/static/switch.svg")   
          .attr("width", 40)
          .attr("height", 40)
          .attr("x", d => d.x - 20)
          .attr("y", d => d.y - 20);


      labelElements = svg.selectAll(".label")
        .data(nodes)
        .enter().append("text")
        .attr("class", "label")
        .text(d => d.id)
        .attr("font-size", 14)
        .attr("dx", 25)
        .attr("dy", 5);

      simulation.on("tick", () => {
        linkElements
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        nodeElements
          .attr("x", d => d.x - 20)  
          .attr("y", d => d.y - 20);

        labelElements
          .attr("x", d => d.x)
          .attr("y", d => d.y);
      });
    }

    function highlightBestPath(bestPath) {
      // Agrega logs para ver los datos de entrada
      console.log("### HighlightBestPath llamado con bestPath:", bestPath, " Tipo:", typeof bestPath, " Contenido:", bestPath);

      if (!bestPath || bestPath.length === 0) {
        console.log("### No hay ruta óptima o está vacía. Limpiando resaltado.");
        // Asegurarse de quitar el resaltado si no hay ruta
        linkElements.classed("highlight", false); 
        return;
      }

      // Crear un Set de pares consecutivos para fácil lookup
      const pathPairs = new Set();
      for (let i = 0; i < bestPath.length - 1; i++) {
        // Asegurarse de que estamos trabajando con strings para la clave del Set
        const pair = bestPath[i].toString() + '-' + bestPath[i+1].toString();
        const reversePair = bestPath[i+1].toString() + '-' + bestPath[i].toString();
        pathPairs.add(pair);
        pathPairs.add(reversePair);  // Bidireccional, por si las aristas no tienen dirección
        console.log(`### Añadiendo pares a pathPairs: ${pair}, ${reversePair}`);
      }
      console.log("### pathPairs Set:", pathPairs);


      linkElements.classed("highlight", d => {
        const srcId = d.source.id.toString();
        const dstId = d.target.id.toString();
        const linkPair = srcId + '-' + dstId;
        const linkReversePair = dstId + '-' + srcId;

        // Agrega logs para ver cada enlace y la comparación
        const isHighlighted = pathPairs.has(linkPair) || pathPairs.has(linkReversePair);
        console.log(`### Comprobando enlace ${srcId}-${dstId}: pathPairs.has('${linkPair}') || pathPairs.has('${linkReversePair}') -> Resultado: ${isHighlighted}`);

        return isHighlighted;
      });

       console.log("### Proceso de resaltado completado.");
    }




    socket.on('update_topology', function(data) {
      // 1) Actualiza el contador
      const counterEl = document.getElementById('snapshot-counter');
      if (counterEl) {
        counterEl.innerText = data.counter !== undefined ? data.counter : '—';
      }

      // Mostrar coste del camino
      const costEl = document.getElementById('path-cost');
      if (costEl) {
        costEl.innerText = data.best_cost !== undefined ? data.best_cost.toFixed(4) : '—';
      }

      // 2) LOG en consola
      console.log('### Datos recibidos en front:', data);
      console.log('### best_path:', data.best_path, ' tipo:', typeof data.best_path[0]);

      // 3) Muestra `best_path` en pantalla
      const display = document.getElementById('best-path-display');
      if (data.best_path && data.best_path.length) {
        display.innerText = 'Ruta óptima: ' + data.best_path.join(' → ');
      } else {
        display.innerText = 'Ruta óptima: —';
      }

      // 4) Resalta enlaces
      highlightBestPath(data.best_path);
    });



    fetch('/topology')
      .then(response => response.json())
      .then(data => {
        console.log('Fetch inicial:', data);
        document.getElementById('best-path-display').innerText =
          data.best_path.length
            ? 'Ruta óptima: ' + data.best_path.join(' → ')
            : 'Ruta óptima: —';
        initializeNetwork(data);
        document.getElementById('snapshot-counter').innerText =
          data.counter !== undefined ? data.counter : '—';

        document.getElementById('path-cost').innerText =
          data.best_cost !== undefined ? data.best_cost.toFixed(4) : '—';

      });

  </script>

</body>
</html>