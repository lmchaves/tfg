<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Visualización de la Red SDN</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <style>
    body { font-family: Arial, sans-serif; }
    svg {
    border: 1px solid black;
    }
    .link { stroke: #999; stroke-width: 2px; }
    .node { fill: steelblue; stroke: white; stroke-width: 2px; cursor: pointer; }
    .highlight { stroke: red; stroke-width: 4px; }
    .control-buttons button {
        margin-right: 10px;
        padding: 5px 10px;
        font-size: 1em;
        cursor: pointer;
    }
    .graph-container {
        display: flex;
        align-items: flex-start; 
        gap: 20px; 
        margin-top: 20px; 
    }
  </style>
</head>
<body>
  <h2>Visualización de la Red SDN</h2>

  <div id="snapshot-info" style="font-size: 1.1em; margin-bottom: 10px;">
    Instantánea: <span id="snapshot-counter">—</span>
  </div>


  <div id="best-path-display" style="font-size: 1.1em; margin-bottom: 10px;">
    Ruta óptima: —
  </div>

  <div id="best-cost">
    Coste: <span id="path-cost">—</span>
  </div>

  <div class="control-buttons">
    <button id="pause-button">Pausa</button>
    <button id="continue-button">Continuar</button>
    <button id="skip-button">Saltar 1</button>
  </div>

  <div id="endpoint-selection" style="margin-top: 20px; margin-bottom: 20px;">
    <h3>Seleccionar Origen y Destino</h3>
    <label for="src-dpid">Origen (DPID):</label>
    <input type="number" id="src-dpid" value="15" min="1"> <label for="dst-dpid" style="margin-left: 20px;">Destino (DPID):</label>
    <input type="number" id="dst-dpid" value="1" min="1"> <button id="set-endpoints-button" style="margin-left: 20px;">Establecer</button>
  </div>
  
  <div class="graph-container">
    <svg width="800" height="1000"></svg>
    <div id="link-info-box" style="margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; min-width: 250px; display: none;">
      <h3>Información del Enlace Seleccionado</h3>
      <div id="link-details">
          Selecciona un enlace en el grafo para ver sus detalles.
      </div>
    </div>
  <div>
  
  



  <script>
    const socket = io.connect('http://127.0.0.1:5000');
    const svg = d3.select("svg");
    let nodes = [];
    let links = [];
    let linkElements, nodeElements, labelElements;
    let simulation;
    const linkInfoBox = d3.select("#link-info-box");
    const linkDetailsDiv = d3.select("#link-details");

    function initializeNetwork(data) {
      nodes = data.switches.map(d => ({ id: d }));
      let nodeMap = new Map(nodes.map(n => [n.id, n]));

      links = data.links.map(l => ({
        source: nodeMap.get(l.src),
        target: nodeMap.get(l.dst),
        load: l.load,
        delay: l.delay,
        packet_loss: l.packet_loss
      }));

      simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(100))
        .force("charge", d3.forceManyBody().strength(-400))
        .force("center", d3.forceCenter(400, 400));

      linkElements = svg.selectAll(".link")
        .data(links)
        .enter().append("line")
        .attr("class", "link")
        .attr("stroke-width", d => d.load * 10)

      linkElements.on("click", function(event, d) {
        console.log("Enlace clicado:", d); 

        linkInfoBox.style("display", "block");

        linkDetailsDiv.html(`
            <p><strong>Carga:</strong> ${(d.load * 100).toFixed(2)} %</p>
            <p><strong>Delay:</strong> ${(d.delay * 1000).toFixed(2)} ms</p>
            <p><strong>Pérdida de Paquetes:</strong> ${(d.packet_loss * 100).toFixed(2)} %</p>
        `);

        linkElements.classed("selected-link", false); 
        d3.select(this).classed("selected-link", true); 
      });


      linkElements.append("title")
        .text(d =>
          `Enlace ${d.source.id}→${d.target.id}\n` +
          `Carga: ${(d.load*100).toFixed(1)}%\n` +
          `Delay: ${(d.delay*1000).toFixed(1)}ms\n` +
          `Pérdida: ${(d.packet_loss*100).toFixed(1)}%`
        );
        
        nodeElements = svg.selectAll(".node")
        .data(nodes)
        .enter().append("image")
          .attr("class", "node")
          .attr("xlink:href", "/static/switch.svg")   
          .attr("width", 40)
          .attr("height", 40)
          .attr("x", d => d.x - 20)
          .attr("y", d => d.y - 20);


      labelElements = svg.selectAll(".label")
        .data(nodes)
        .enter().append("text")
        .attr("class", "label")
        .text(d => d.id)
        .attr("font-size", 14)
        .attr("dx", 25)
        .attr("dy", 5);

      simulation.on("tick", () => {
        linkElements
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        nodeElements
          .attr("x", d => d.x - 20)  
          .attr("y", d => d.y - 20);

        labelElements
          .attr("x", d => d.x)
          .attr("y", d => d.y);
      });
    }

    function highlightBestPath(bestPath) {
      // Agrega logs para ver los datos de entrada
      console.log("### HighlightBestPath llamado con bestPath:", bestPath, " Tipo:", typeof bestPath, " Contenido:", bestPath);

      if (!bestPath || bestPath.length === 0) {
        console.log("### No hay ruta óptima o está vacía. Limpiando resaltado.");
        // Asegurarse de quitar el resaltado si no hay ruta
        linkElements.classed("highlight", false); 
        return;
      }

      // Crear un Set de pares consecutivos para fácil lookup
      const pathPairs = new Set();
      for (let i = 0; i < bestPath.length - 1; i++) {
        // Asegurarse de que estamos trabajando con strings para la clave del Set
        const pair = bestPath[i].toString() + '-' + bestPath[i+1].toString();
        const reversePair = bestPath[i+1].toString() + '-' + bestPath[i].toString();
        pathPairs.add(pair);
        pathPairs.add(reversePair);  // Bidireccional, por si las aristas no tienen dirección
        console.log(`### Añadiendo pares a pathPairs: ${pair}, ${reversePair}`);
      }
      console.log("### pathPairs Set:", pathPairs);


      linkElements.classed("highlight", d => {
        const srcId = d.source.id.toString();
        const dstId = d.target.id.toString();
        const linkPair = srcId + '-' + dstId;
        const linkReversePair = dstId + '-' + srcId;

        // Agrega logs para ver cada enlace y la comparación
        const isHighlighted = pathPairs.has(linkPair) || pathPairs.has(linkReversePair);
        console.log(`### Comprobando enlace ${srcId}-${dstId}: pathPairs.has('${linkPair}') || pathPairs.has('${linkReversePair}') -> Resultado: ${isHighlighted}`);

        return isHighlighted;
      });

       console.log("### Proceso de resaltado completado.");
    }

    // Función para enviar comandos de control al servidor Flask
    function sendControlCommand(command, steps = 1) {
      // Envía el comando usando Socket.IO
      socket.emit('control_command', { command: command, steps: steps });
      console.log(`### Comando de control enviado: ${command} con pasos ${steps}`);
    }

    function sendEndpoints() {
        const srcDpid = parseInt(document.getElementById('src-dpid').value, 10);
        const dstDpid = parseInt(document.getElementById('dst-dpid').value, 10);

        if (isNaN(srcDpid) || srcDpid <= 0 || isNaN(dstDpid) || dstDpid <= 0) {
            alert("Por favor, ingrese DPIDs v\u00E1lidos (n\u00FAmeros mayores que 0).");
            return;
        }

        // Enviar un nuevo tipo de comando a Flask
        socket.emit('control_command', {
            command: 'set_endpoints',
            src: srcDpid,
            dst: dstDpid
        });
        console.log(`### Enviando nuevos puntos finales: Origen ${srcDpid}, Destino ${dstDpid}`);
    }




    socket.on('update_topology', function(data) {
      // 1) Actualiza el contador
      const counterEl = document.getElementById('snapshot-counter');
      if (counterEl) {
        counterEl.innerText = data.counter !== undefined ? data.counter : '—';
      }

      // Mostrar coste del camino
      const costEl = document.getElementById('path-cost');
      if (costEl) {
        costEl.innerText = data.best_cost !== undefined ? data.best_cost.toFixed(4) : '—';
      }

      // 2) LOG en consola
      console.log('### Datos recibidos en front:', data);
      console.log('### best_path:', data.best_path, ' tipo:', typeof data.best_path[0]);

      // 3) Muestra `best_path` en pantalla
      const display = document.getElementById('best-path-display');
      if (data.best_path && data.best_path.length) {
        display.innerText = 'Ruta óptima: ' + data.best_path.join(' → ');
      } else {
        display.innerText = 'Ruta óptima: —';
      }

      // 4) Resalta enlaces
      highlightBestPath(data.best_path);
    });



    fetch('/topology')
      .then(response => response.json())
      .then(data => {
        console.log('Fetch inicial:', data);
        document.getElementById('best-path-display').innerText =
          data.best_path.length
            ? 'Ruta óptima: ' + data.best_path.join(' → ')
            : 'Ruta óptima: —';
        initializeNetwork(data);
        document.getElementById('snapshot-counter').innerText =
          data.counter !== undefined ? data.counter : '—';

        document.getElementById('path-cost').innerText =
          data.best_cost !== undefined ? data.best_cost.toFixed(4) : '—';

      });

    // Event Listeners para los botones 
    document.getElementById('pause-button').addEventListener('click', () => {
        sendControlCommand('pause');
    });

    document.getElementById('continue-button').addEventListener('click', () => {
        sendControlCommand('continue');
    });

    document.getElementById('skip-button').addEventListener('click', () => {
        sendControlCommand('skip', 1); // Saltar 1 instant\u00E1nea
    });

    // Si a\u00F1adiste un input y un bot\u00F3n para saltar N pasos:
    // document.getElementById('skip-multiple-button').addEventListener('click', () => {
    //     const steps = parseInt(document.getElementById('skip-steps').value, 10);
    //     if (!isNaN(steps) && steps > 0) {
    //         sendControlCommand('skip', steps);
    //     } else {
    //         alert("Por favor, ingrese un n\u00FAmero v\u00E1lido de instant\u00E1neas para saltar.");
    //     }
    // });

    document.getElementById('set-endpoints-button').addEventListener('click', () => {
        sendEndpoints(); 
    });

  </script>

</body>
</html>