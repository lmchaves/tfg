<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Visualización de la Red SDN</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <style>
    body { font-family: Arial, sans-serif; }
    svg { border: 1px solid black; }
    .link { stroke: #999; stroke-width: 2px; }
    .node { fill: steelblue; stroke: white; stroke-width: 2px; cursor: pointer; }
    .highlight { stroke: red; stroke-width: 4px; }
  </style>
</head>
<body>
  <h2>Visualización de la Red SDN</h2>
  <svg width="600" height="400"></svg>

  <script>
    // Conectar a Socket.IO en Flask
    const socket = io.connect('http://127.0.0.1:5000');
    const svg = d3.select("svg");

    function drawNetwork(data) {
      svg.selectAll("*").remove();

      // Crear nodos a partir de los switches
      let nodes = data.switches.map(d => ({ id: d }));
      let nodeMap = new Map(nodes.map(n => [n.id, n]));

      // Crear enlaces usando la información de "links"
      let links = data.links.map(l => ({
        source: nodeMap.get(l.src),
        target: nodeMap.get(l.dst),
        load: l.load,
        delay: l.delay,
        packet_loss: l.packet_loss
      }));

      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(100))
        .force("charge", d3.forceManyBody().strength(-400))
        .force("center", d3.forceCenter(300, 200));

      const link = svg.selectAll(".link")
        .data(links)
        .enter().append("line")
        .attr("class", "link")
        .attr("stroke-width", d => d.load * 10);

      const node = svg.selectAll(".node")
        .data(nodes)
        .enter().append("circle")
        .attr("class", "node")
        .attr("r", 20);

      const label = svg.selectAll(".label")
        .data(nodes)
        .enter().append("text")
        .attr("class", "label")
        .text(d => d.id)
        .attr("font-size", 14)
        .attr("dx", 25)
        .attr("dy", 5);

      simulation.on("tick", () => {
        link.attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        node.attr("cx", d => d.x)
            .attr("cy", d => d.y);

        label.attr("x", d => d.x)
             .attr("y", d => d.y);
      });

      // Resaltar la mejor ruta, si se proporciona
      if (data.best_path && data.best_path.length > 0) {
        link.filter(d => {
          // Resalta los enlaces que conectan switches consecutivos de la ruta óptima.
          let idxSource = data.best_path.indexOf(d.source.id.toString());
          let idxTarget = data.best_path.indexOf(d.target.id.toString());
          return idxSource !== -1 && idxTarget !== -1 && Math.abs(idxSource - idxTarget) === 1;
        }).classed("highlight", true);
      }
    }

    function fetchData() {
      fetch('/topology')
        .then(response => response.json())
        .then(data => {
          console.log("Datos recibidos:", data);
          drawNetwork(data);
        })
        .catch(err => console.error("Error al obtener datos:", err));
    }

    socket.on('update_topology', function(data) {
      drawNetwork(data);
    });

    // Llamada inicial y actualización cada 5 segundos
    fetchData();
    setInterval(fetchData, 5000);
  </script>
</body>
</html>
